import Cocoa
import WarpCore

class QBEDocument: NSDocument, NSSecureCoding {
	private(set) var tablets: [QBETablet] = []
	private(set) var savedAtLeastOnce = false
	
	override init () {
	}
	
	required init?(coder aDecoder: NSCoder) {
		if let head = aDecoder.decodeObjectOfClass(QBEStep.self, forKey: "head") {
			let legacyTablet = QBEChainTablet(chain: QBEChain(head: head))
			tablets.append(legacyTablet)
		}
		else {
			let classes = Set<NSObject>(arrayLiteral: [QBETablet.self, NSArray.self])
			tablets = aDecoder.decodeObjectOfClasses(classes, forKey: "tablets") as? [QBETablet] ?? []
		}
		
		super.init()
		tablets.forEach { $0.document = self }
	}
	
	func removeTablet(tablet: QBETablet) {
		assert(tablet.document == self, "tablet must belong to this document")
		tablet.document = nil
		tablets.remove(tablet)
	}
	
	func addTablet(tablet: QBETablet) {
		assert(tablet.document == nil, "tablet must not be associated with another document already")
		tablet.document = self
		tablets.append(tablet)
	}
	
	override func windowControllerDidLoadNib(aController: NSWindowController) {
		super.windowControllerDidLoadNib(aController)
		// Add any code here that needs to be executed once the windowController has loaded the document's window.
	}
	
	override class func autosavesInPlace() -> Bool {
		return true
	}
	
	override func makeWindowControllers() {
		let storyboard = NSStoryboard(name: "Main", bundle: nil)

		if !QBESettings.sharedInstance.once("tour", callback: { () -> () in
			let ctr = storyboard.instantiateControllerWithIdentifier("tour") as! NSWindowController
			ctr.window?.titleVisibility = .Hidden
			self.addWindowController(ctr)
		}) {
			let windowController = storyboard.instantiateControllerWithIdentifier("Document Window Controller") as! NSWindowController
			self.addWindowController(windowController)
		}
	}
	
	func encodeWithCoder(coder: NSCoder) {
		coder.encodeObject(tablets, forKey: "tablets")
	}
	
	static func supportsSecureCoding() -> Bool {
		return true
	}
	
	override func dataOfType(typeName: String) throws -> NSData {
		let data = NSMutableData()
		let ka = NSKeyedArchiver(forWritingWithMutableData: data)
		ka.setClassName("Warp.QBETablet.v2", forClass: QBETablet.classForKeyedArchiver()!)
		ka.encodeObject(self, forKey: "root")
		ka.finishEncoding()
		return data
	}

	override func saveDocument(sender: AnyObject?) {
		savedAtLeastOnce = true
		super.saveDocument(sender)
		self.updateWindowControllers()
	}

	override func saveDocumentAs(sender: AnyObject?) {
		savedAtLeastOnce = true
		super.saveDocument(sender)
		self.updateWindowControllers()
	}

	override func saveDocumentWithDelegate(delegate: AnyObject?, didSaveSelector: Selector, contextInfo: UnsafeMutablePointer<Void>) {
		savedAtLeastOnce = true
		super.saveDocumentWithDelegate(delegate, didSaveSelector: didSaveSelector, contextInfo: contextInfo)
		self.updateWindowControllers()
	}

	private func updateWindowControllers() {
		self.windowControllers.forEach { dc in
			if let qdc = dc as? QBEWindowController {
				qdc.update()
			}
		}
	}
	
	override func writeToURL(url: NSURL, ofType typeName: String) throws {
		self.tablets.forEach { $0.willSaveToDocument(url) }
		try super.writeToURL(url, ofType: typeName)
		self.updateWindowControllers()
	}
	
	override func readFromURL(url: NSURL, ofType typeName: String) throws {
		try super.readFromURL(url, ofType: typeName)
		self.tablets.forEach { $0.didLoadFromDocument(url) }
		self.updateWindowControllers()
	}
	
	override func readFromData(data: NSData, ofType typeName: String) throws {
		let unarchiver = NSKeyedUnarchiver(forReadingWithData: data)

		// Ensure that old classes referenced in files generated by older versions of this software can be found
		unarchiver.setClass(QBERectangle.classForKeyedUnarchiver(), forClassName: "_TtC4WarpP33_B11F6D3701F49B735237E0045569881C12QBERectangle")
		unarchiver.setClass(Order.classForKeyedUnarchiver(), forClassName: "WarpCore.QBEOrder")
		unarchiver.setClass(Aggregation.classForKeyedUnarchiver(), forClassName: "WarpCore.QBEAggregation")
		unarchiver.setClass(Expression.classForKeyedUnarchiver(), forClassName: "WarpCore.QBEExpression")
		unarchiver.setClass(FilterSet.classForKeyedUnarchiver(), forClassName: "WarpCore.QBEFilterSet")
		unarchiver.setClass(DataDefinition.classForKeyedUnarchiver(), forClassName: "WarpCore.QBEDataDefinition")
		unarchiver.setClass(Raster.classForKeyedUnarchiver(), forClassName: "WarpCore.QBERaster")
		unarchiver.setClass(Sibling.classForKeyedUnarchiver(), forClassName: "WarpCore.QBESiblingExpression")
		unarchiver.setClass(Literal.classForKeyedUnarchiver(), forClassName: "WarpCore.QBELiteralExpresion")
		unarchiver.setClass(Call.classForKeyedUnarchiver(), forClassName: "WarpCore.QBEFunctionExpression")
		unarchiver.setClass(Moving.classForKeyedUnarchiver(), forClassName: "WarpCore.QBEMoving")
		unarchiver.setClass(ValueCoder.classForKeyedUnarchiver(), forClassName: "WarpCore.QBEValueCoder")
		unarchiver.setClass(Foreign.classForKeyedUnarchiver(), forClassName: "WarpCore.QBEForeignExpression")
		unarchiver.setClass(Comparison.classForKeyedUnarchiver(), forClassName: "WarpCore.QBEBinaryExpression")
		unarchiver.setClass(Identity.classForKeyedUnarchiver(), forClassName: "WarpCore.QBEIdentityExpression")
		unarchiver.setClass(QBEChainTablet.classForKeyedUnarchiver(), forClassName: "Warp.QBETablet")

		if let x = unarchiver.decodeObjectForKey("root") as? QBEDocument {
			tablets = x.tablets
			tablets.forEach { $0.document = self }
		}
		unarchiver.finishDecoding()
	}
}